Phase 1: データ構造と初期化 (Data & Init)
まずはシェルの「脳」と「血液」を作ります。

環境変数の管理機構

<!--main の引数 envp を受け取り、使いやすい形（リンクリスト推奨）にコピーする。-->

後で export / unset で増減できるようにするため。

メインループの作成

<!--readline を使って入力を受け取り、ヒストリに保存する無限ループを作る。-->

<!--Ctrl+D (EOF) が来たら NULL が返るので、ループを抜けて終了する。-->

Phase 2: 入力解析 (Parsing) - "言語を理解する"
入力された文字列を、実行可能な形に変換します。

字句解析 (Lexer) / トークナイズ

<!--文字列をスペースで区切る。-->

<!--クォート処理: ' と " の中身はスペースがあっても区切らない。-->

<!--メタ文字: |, <, >, <<, >> はスペースがなくても区切りとみなす。-->

変数の展開 (Expander)

<!--トークン内の $ を見つけて環境変数の中身に置き換える。-->
Milestone 3
Milestone 4

<!--ルール: " の中と通常時は展開する。' の中は展開しない。-->

<!--$? (終了ステータス) の展開も実装する。-->

<!--クォート削除: 区切りに使った ' や " を最後に削除する。-->

構文解析 (Parser) / AST構築

<!--トークンリストを木構造（二分木）に変換する。-->

ノードの種類: PIPE (節), CMD (葉), REDIRECT.

<!--構造: PIPE の左が実行コマンド、右が次の処理。-->

Phase 3: 実行機能 (Execution) - "コマンドを走らせる"
<!--木構造を再帰的に巡回して実行します。-->

<!--パイプラインの構築 (|)

pipe() でパイプ作成。

fork() で子プロセス生成。

親の仕事: 左右の子を産み終えるまでループ。不要なファイルディスクリプタ（FD）を必ず閉じる。

子の仕事: dup2() で標準入出力をパイプにつなぎ変える。

コマンド実行 (execve)-->

<!--パスの解決: 環境変数 $PATH を分解し、コマンド名（例: ls）と結合して実行可能ファイル（例: /bin/ls）を探す。-->

<!--execve() を実行（引数は配列 char **argv で渡す）。-->

<!--シグナル設定をデフォルトに戻す。-->

<!--リダイレクト処理 (<, >, >>)-->

execve の直前に処理する。

<!--open() して dup2() で標準入出力（0, 1）をファイルにすり替える。-->

<!--待機処理 (waitpid)-->

<!--全ての子プロセスを起動し終えてから、親がまとめて waitpid で待つ。-->

<!--終了ステータスを取得し、$? 用の変数に保存する。-->

<!--Phase 4: ビルトインコマンド (Builtins) - "自前で実装"-->
<!--外部コマンドではなく、関数として実装します。-->

親プロセスで実行必須:
<!--
cd: chdir() を呼んでシェルのカレントディレクトリを変更。

exit: シェルを終了。

export: 環境変数リストに追加。

unset: 環境変数リストから削除。

子プロセスでもOK（出力系）:

echo: -n オプション対応。

pwd: getcwd() で現在地表示。

env: 環境変数一覧を表示。-->

Phase 5: シグナルと仕上げ (Signals & Polish)
シェルの挙動をBashに近づけます。
<!--
シグナルハンドリング

Ctrl+C:

入力待機中: 改行して新しいプロンプトを表示。

実行中: 親は何もしない（改行のみ出力）、子は死ぬ。

Ctrl+\:

入力待機中: 無視（何もしない）。

実行中: 子プロセスのみ反応（Core Dump）。-->

<!--ヒアドキュメント (<<)-->

<!--デリミタが来るまで入力を読み、パイプか一時ファイルに保存してコマンドに渡す。-->

メモリ管理

<!--パースした木構造、環境変数リスト、分割した文字列などを適切に free する。-->